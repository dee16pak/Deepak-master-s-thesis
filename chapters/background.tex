\chapter{Background}
\label{ch:bcg}
\section{Ethereum}
Ethereum was proposed in late 2013 by Vitalik Buterin, a cryptocurrency researcher and programmer. The development of ethereum was funded by an online crowdsale that took place between July and August 2014. The system then went live on 30 July 2015, with 72 million coins minted\cite{eth1reum}. Ethereum is an open source, blockchain based distributed computing system. Ethereum is the second largest cryptocurrency in terms of market capitalisation after the bitcoin.On Ethereum, we can write code that controls the money, and build applications accessible anywhere in the world. While all other blockchains also have the ability to process code, most are severely limited. Ethereum on the other hand rather than giving a set of limited operations, it allows developers to create whatever operations they want. This opens a wide area to explore and we can see more exciting and innovative Apps and concepts on ethereum. For example we can develop games, manage financial transactions, building multi party system and many more. 
\\ 
Smart contract on ethereum can let developers and organisations to code their Apps( called as Distributed Apps because they are built on distributed network, ethereum). These smart contracts are like computer programs and execute the exact functionality/logic using EVM. These apps once deployed is opened to public and cannot be tampered with because of the blockchain property and because of this ethereum is growing rapidly in popularity. Increasing numbers of organizations are embracing Ethereum for new projects. The variety of projects that use Ethereum as their foundation is almost limitless. 
The State of the dApps website\cite{sdapp} shows how many Ethereum projects exist in different categories and how popular they are. Some sample examples of how ethereum can be used shown here\cite{dummies} are listed below:\\
\begin{itemize}
    \item Gnosis\cite{gnosis} and Augur\cite{augur} are many of the innovative companies using ethereum in interesting ways. Both provides a platform for the prediction markets. Users use company specific tokens to predict and and wins token for successful predictions. These predictions are useful for the others who are looking for investment in stocks etc.
    \item We can also find some games in the ethereum space as. Cryptokitties\cite{cryptokitties} is one of the ethereum first games which is still popular. The game introduced blockchain-based cryptocollectibles. Cryptokitties are breed from the cattributes of their parents. The popularity of games can be seen from the fact that some of the cryptokitties are sold for over \$10000 USD in the past.
    \item  Ethereum platform is also used to make social platform to share thoughts. EtherTweet\cite{ethertweet} is the blockchain based alternative to twitter.
    \item Ethereum can be used to search for jobs using EthLance\cite{ethlance}. EthLance is a distributed platform for freelancers and employers to find each other, engage in jobs, and transfer payment in ether and so on.
\end{itemize}
and many more...\\

The transaction rate on ethereum is around 7-8 lakhs per day\cite{etherscanchart}. The total supply of Ether was around 100 million as of 16 April 2020\cite{ether} and around 2M smart contracts already deployed on ethereum\cite{cointelegrah}. With so many smart contracts deployed and money involved, attracts the attackers to find and exploit vulnerabilities in the smart contracts. We have seen many vulnerabilities in the past because of which there was huge loss of money/ether\cite{dasp}. Few famous vulnerabilities are listed below.
\begin{itemize}
    \item The reentrency attack is among the most famous on ethereum. Reentrency occurs when an external called contract is allowed to make call to the calling contract without completing the previous execution. The famous DAO attack\cite{dao} is an example of the reentrency attack which cost around 50USD at the time.
    \item Access control issues which allowed any external user to perform privilege operations. One usually access these access through the public or external functions and insecure visibility settings gives direct opportunity to attackers. This vulnerability costed around 30M USD at the time. The real world impact due to access control are Parity Multi-sig Bug 1\cite{self1}, Parity Multi-sig Bug 2\cite{self2} and Rubixi\cite{rubixi} etc.
    \item Denial of service is dangerous in the world of Ethereum. While other types of applications can eventually recover, smart contracts can be taken offline forever by just one of these attacks. There are many ways that lead to denials of service, these include maliciously behaving when being the recipient of a transaction, increasing the gas necessary to compute a function , abusing access controls to access private components of smart contracts, taking advantage of mix ups and negligence, etc. This class of attack includes many different variants and will probably see a lot of development in the years to come. The total estimated loss because of Denial of Service is around 300M USD at the time. Real world impact/ examples are GovernMental\cite{governmental}, King of Ether contract\cite{koet1} and Parity Multi-sig Wallet\cite{self2} etc.
\end{itemize}  

\section{Smart Contracts}
Smart contracts are terms and conditions which the two parties agreed upon before doing business with each other\cite{ctbegin}. These enforce these terms and conditions programatically and thus removes middle man who in the absence of smart contract is the main enforcer of the terms and conditions. The middle man sometimes can favour one person over the other and can change the terms and conditions in order to get some money or cheat the other person. Smart contract reduces this fraud and removes the issue of trust because this are computer programs which runs exactly programmed and cannot be changed if they are implemented on blockchain. Example : Ethereum Smart Contracts etc. A smart contract can work on its own and it can also be implemented along with any number of smart contracts. For example a smart contract can be called from other smart contract, successful completion of one contract can trigger the second and so. We can make the complete organisation run on smart contract. \\
Smart contracts gives a number of benefits. Smart contract eradicate the need of third party involved in the transaction. They provides trust as no one can steal them and are stored on public ledger which can be seen by everyone and are verified by 100's or 1000's of nodes. Smart contracts save money by eliminating the notary, estate agents, assistance's etc charges. Smart contracts, if implemented correctly, provides safety as these are very hard to hack. Smart contract also save a lots of time which will otherwise be wasted on manually processing lots of paper work,  sending and receiving transportation time etc.\\
Smart contracts were first proposed in the early 1990s by computer scientist, lawyer and cryptographer Nick Szabo. However the implementation of smart contracts did not happen until 2009, when the first cryptocurrency blockchain bitcoin came and provides suitable environment for the implementation of smart contracts. But their implementation still is very much regulated and controlled by the bitcoin. But with the arrival of ethereum, the smart contract gets more freedom because of the Turing completeness of EVM and become the most hyped feature of ethereum. Smart contracts can now implement almost all the practical life examples.\\
Smart contracts are extremely new technology. Despite of so many attractive promises, they can still be prone to problems. The code of the smart smart contract logic must be accurate and contains no bugs. This can lead to mistakes and most of the time are exploited by attackers for the wrong doing to the system/ smart contracts. For example the DAO hack, King of Ether vulnerability are the examples of ethereum smart contracts where scammers found vulnerabilities in the smart contract logic and exploited them.
\section{Ethereum Smart contract Programming}
Any program that runs on the Ethereum Virtual Machine (EVM) is commonly referred to as a smart contract. The most popular languages for writing smart contracts on Ethereum are Solidity and Vyper. Solidity is the most popular language on ethereum, inspired by C++, python and javascript. Vyper is based on python. The IDE's for the ethereum developments are Visual Studio Code with official ethereum support, Remix is a web based IDE with built in static analysis, and a test blockchain virtual machine and EthFiddle is also an web based smart contract to write, compile and debug smart contracts. We have used Remix to generate bytcode for our sample test smart contracts.
\section{ByteCode}
When we compile the high level smart contract code, say for example a solidity file on Remix, it will translate the high level code into the bytecode. The bytecode is a hexadecimal representation of the smart contract. Since this bytecode will run on the EVM, the EVM have predefined opcodes. The bytecode contains these opcodes into their hexadecimal values. Every opcode have a hexadecimal values. The mapping of hexadecimal values to the opcodes can be seen in the ethereum yellow paper and here. EVM is a stack based machine and every opcode take arguments from the stack and processes on those arguments and put back the result on the stack. There are some opcodes which puts data on the stack without processing. Lets look at these opcodes below.
\begin{itemize}
    \item \textbf{Opcodes of execution environment}: For example PC for program counter and MSIZE for current memory size.
    \item \textbf{Opcodes for transaction}: These are the opcodes that contain details about the transaction payload used to call smart contract, for example, CALLVALUE stores the ether value sent along with the transaction, CALLDATASIZE returns the size of CALLDATA(transaction payload) etc.
    \item \textbf{Opcodes to push constant values on the Stack} : These opcodes push constant values on the stack to process further.For example, PUSH opcode that pushes value on the stack. The PUSH opcode can push different bytes of data on the stack base on the prefix number attached to the PUSH. For example PUSH1 pushes 1 byte of data onto the stack, PUSH8 pushes 8 byte of data onto the stack and so on. The highest value that can be pushed on the stack is of 32 bytes by PUSH32. there is no PUSH33 and above. 
\end{itemize}
The recent 16 values on the top of the stack are accessible because of which we have opcodes for duplicate and swap stack values with prefix DUP1...DUP16 and SWAP1...SWAP16.\\
There are certain opcodes used for identifying symbolic variables in the bytecode. These opcodes are basically those which are to to process data about the CALLDATA. CALLDATA is the transaction payload string that is send as transaction to call a contract. This string is send as transaction to call a contract. External users interact with the smart contracts on ethereum blockchain this way. A list of opcodes for processing the CALLDATA is listed below.
\begin{itemize}
    \item \textbf{CALLVALUE} : CALLVALUE stores the ether value send by the calling contract. This is decided by the external user who is calling the contract and hence we treated this value as symbolic.
    \item \textbf{Calling External Contract from the Contract} : The return value of calls made to external contract from the contract are purely symbolic as we don't know the external smart contract. It is generally a boolean value for successfully completion of the execution of external smart contract or for the failure of execution of the external smart contract. The opcodes for calling external smart contracts are CALL, CALLCODE, DELEGATECALL and STATICCALL.
    \item \textbf{CALLDATALOAD(x)} : The opcode CALLDATALOAD(x) is used for loading a specific part of the CALLDATA string starting from xth byte upto 32 bytes either for the purpose of loading external function signature in the payload string which the user want to call in the smart contract or for the function arguments provides in the payload string to call the particular functions. As these are purely set by the caller the smart contract don't know what value is coming in the payload and hence we set all these as symbolic.
    \item \textbf{CALLDATACOPY(t, f, s)} : CALLDATACOPY(t, f, s) copies \emph{s} bytes from calldata at position \emph{f} to memory at position \emph{t}. These bytes stored in memory are all stored as symbolic variables.
    \item \textbf{CALLDATASIZE} : CALLDATASIZE returns the size of the calldata in bytes is also treated as symbolic.
\end{itemize}
    
There are mainly two types of bytecode\cite{bytecode1}:
\begin{itemize}
    \item \textbf{Creation Bytecode} : When a smart contract is compiled creation bytecode is generated. This is the code that generates runtime bytecode. It contains constructor logic and constructor parameters of a smart contract. This code sets the initial parameters using constructor and returns the runtime bytecode which is actual smart contract. The creation bytecode is equivalent to the payload of the transaction the creates a contract, provided the sole purpose of the transaction is to create the contract.\\

    The creation bytecode for a contract can be retrieved on-chain by using
    \begin{center}
        \emph{type(ContractName).creationCode}
    \end{center} 
    \item \textbf{Runtime Bytecode} : Runtime  Bytecode is the code that is stored on-chain that describes a smart contract. This code does not contain constructor logic and constructor parameters as these are not relevant to the smart contract once it is deployed on the blockchain. \\
    The runtime bytecode for a contract can be retrieved on-chain by using an assembly block and calling
    \begin{center}
        \emph{extcodecopy(a)}
    \end{center} 
    And the hash of the runtime bytecode is returned from 
    \begin{center}
        \emph{extcodehash(a)}
    \end{center} 
\end{itemize}
\section{Ethereum Virtual Machine(EVM)}
Virtual machines are essentially creating a level of abstraction between the executing code and the executing machine. This layer is needed to improve the portability of software, as well as to make sure applications are separated from each other, and separated from their host. All nodes in the ethereum network agree on how should EVM behave. This helps in achieving consensus for the data and the code on the code as everyone will get the same data due to their agreement on EVM\cite{whatisEVM}.\\
EVM is a stack based machine with the maximum limit of the stack is 1024. EVM also keeps track of the gas usage in order to terminate program when out of gas. In this thesis we implemented a Custom EVM which only executes bytecode instead of implementing fully functional EVM. Hence a knowledge of all storage components is sufficient. The Ethereum virtual machine specification lists three separate storage\cite{bitdegree} as listed below:
\begin{itemize}
    \item \textbf{Stack} : EVM is a stack based machine. The stack is the area where all general purpose computation happens. The stack size can goes upto a maximum of 1024. If a contract reaches this stack size the EVM stops execution of the contract. The stack can hold upto a maximum of 32byte of data item. Stack is the cheapest memory in terms of gas consumption.
    \item \textbf{Memory} : Memory is linear and holds temporary variable because memory is temporary and erased between function calls. Memory can be seen as an additional assist to the stack computation for the execution of the current call. The maximum bytes of data that can be read at one time from a memory is 32 bytes. We can write from a range of 8bit to 256bits of data on the memory. To expand memory from a default size one needs to pay extra gas. Memory scales quadratically and the more it grows, more it costs. 
    \item \textbf{Storage} : Storage is used to store smart contract's state. This is permanent between function calls. The gas consumption is highest of all the three memory in case of storage.
\end{itemize}
\section{Control Flow Graph}
Control flow graph is a representation, using graph notations, of all the paths that a program might traverse during its execution\cite{controlflow}. Each node in the control flow graph is called as a basic block. Directed edges are used in the control flow graph to show the control flow from one basic block to another. The control flow graphs can be used to detect loops, detect various control structures, for example, loops, if-the-else etc in the program. 
\section{Denial of Service Attack}
In computing, a denial-of-service attack (DoS attack) is a cyber-attack in which the perpetrator seeks to make a machine or network resource unavailable to its intended users by temporarily or indefinitely disrupting services of a host connected to the Internet\cite{dos}. 


